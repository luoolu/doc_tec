# 用本机 Clash 代理“反向喂给”远端服务器（含 PyCharm Host、命令行、浏览器）

> 目标：本机已能通过 Clash 访问海外；将**本机代理**通过 **SSH 反向端口转发**提供给**远端服务器**使用，使得
>
> 1. PyCharm **Host** 端、2) 服务器命令行工具（curl/pip/git/apt…）、3) 服务器图形浏览器 均可出海。

---

## 前提

* 本机（Laptop/Workstation）运行 Clash。常见端口：

  * HTTP 代理：`127.0.0.1:7897`
  * SOCKS5 代理：`127.0.0.1:7890`
* 远端服务器示例：`luolu@10.122.5.97`
* 反向端口建议（**在服务器监听**）：

  * HTTP：`127.0.0.1:17897 → (本机)127.0.0.1:7897`
  * SOCKS：`127.0.0.1:17890 → (本机)127.0.0.1:7890`（可选，推荐）

> 远端 `sshd` 需允许转发：`AllowTcpForwarding yes`（默认允许）。

---

## 步骤总览

1. 在**本机**建立 SSH **反向端口转发**（临时/常驻二选一）。
2. 在 PyCharm 中让 **Host** 走 `127.0.0.1:17897`（或 SOCKS 的 `17890`）。
3. 在**服务器**设置命令行全局代理、单独工具代理（apt/git/pip/docker…）。
4. 在**服务器**浏览器设置代理（Firefox/Chrome 或 GNOME 系统代理）。
5. 提供一键开关脚本 & 故障排查。

---

## 1) 建立反向隧道（本机执行）

### 1.1 临时后台运行（简单可靠）

```bash
# 本机执行：将服务器的 127.0.0.1:17897 → 本机 127.0.0.1:7897 (HTTP)
ssh -fN -o ExitOnForwardFailure=yes \
    -o ServerAliveInterval=30 -o ServerAliveCountMax=3 \
    -R 127.0.0.1:17897:127.0.0.1:7897 \
    luolu@10.122.5.97

# （可选）再开一条 SOCKS 隧道：服务器的 127.0.0.1:17890 → 本机 127.0.0.1:7890
ssh -fN -o ExitOnForwardFailure=yes \
    -o ServerAliveInterval=30 -o ServerAliveCountMax=3 \
    -R 127.0.0.1:17890:127.0.0.1:7890 \
    luolu@10.122.5.97
```

### 1.2 本机 `~/.ssh/config` 别名（便于手动起停）

```sshconfig
# 本机：~/.ssh/config
Host falconcore-rpf
  HostName 10.122.5.97
  User luolu
  ExitOnForwardFailure yes
  ServerAliveInterval 30
  ServerAliveCountMax 3
  RemoteForward 127.0.0.1:17897 127.0.0.1:7897
  RemoteForward 127.0.0.1:17890 127.0.0.1:7890
```

启动（前台）：

```bash
ssh -N falconcore-rpf
```

后台：

```bash
ssh -fN falconcore-rpf
```

### 1.3 `autossh + systemd --user`（强烈推荐，掉线自愈）

```bash
# 本机
sudo apt -y install autossh
mkdir -p ~/.config/systemd/user
cat > ~/.config/systemd/user/falconcore-rpf.service <<'EOF'
[Unit]
Description=Reverse forward server->local Clash

[Service]
Environment=AUTOSSH_GATETIME=0
ExecStart=/usr/bin/autossh -M 0 -N \
  -o ExitOnForwardFailure=yes \
  -o ServerAliveInterval=30 -o ServerAliveCountMax=3 \
  -R 127.0.0.1:17897:127.0.0.1:7897 \
  -R 127.0.0.1:17890:127.0.0.1:7890 \
  luolu@10.122.5.97
Restart=always
RestartSec=5

[Install]
WantedBy=default.target
EOF

systemctl --user daemon-reload
systemctl --user enable --now falconcore-rpf.service
systemctl --user status falconcore-rpf.service
```

### 1.4 在**服务器**验证隧道已就绪

```bash
# 服务器执行
ss -tlnp | grep -E '17897|17890'      # 应看到 LISTEN on 127.0.0.1:17897/17890

# HTTP 验证
curl -I --proxy http://127.0.0.1:17897 https://www.google.com -m 10

# SOCKS 验证（如开了 17890）
curl -I --socks5-hostname 127.0.0.1:17890 https://www.google.com -m 10
```

返回 200/301/302 等即 OK。

> 注意：**不要 Ctrl-C** 杀掉建立隧道的 ssh 进程；否则监听消失。

---

## 2) PyCharm 中让 **Host** 走代理（服务器端 IDE 后端）

PyCharm → `Settings → Appearance & Behavior → System Settings → HTTP Proxy → Host`

* **Manual proxy configuration**
* 协议选 **HTTP**（若用了 17897），或 **SOCKS**（若用了 17890）
* Hostname: `127.0.0.1`
* Port: `17897`（或 `17890`）
* “No proxy for”：`127.0.0.1, localhost, 10.* , 172.16.* , 192.168.*`
* 点击 **Check Connection**

---

## 3) 服务器命令行走代理

### 3.1 清理冲突（常见：公司全局代理）

```bash
# 服务器执行
env | grep -i proxy || true
unset http_proxy https_proxy ftp_proxy all_proxy HTTP_PROXY HTTPS_PROXY FTP_PROXY ALL_PROXY
```

> **curl 会读取配置文件**：
>
> * 用户级：`~/.curlrc`（优先）
> * 系统级：`/etc/curlrc`
>   若系统级写了公司代理，使用者无需改系统级；**在 `~/.curlrc` 覆盖即可**（见下）。

### 3.2 环境变量（HTTP 方案 / SOCKS 方案 二选一）

**A) HTTP 方案（apt 等必需用 HTTP）：**

```bash
# 服务器：~/.bashrc 追加
export http_proxy="http://127.0.0.1:17897"
export https_proxy="$http_proxy"
export HTTP_PROXY="$http_proxy"
export HTTPS_PROXY="$http_proxy"
export no_proxy="127.0.0.1,localhost,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16"
export NO_PROXY="$no_proxy"
```

**B) SOCKS 方案（推荐配合 17890，DNS 亦经隧道）：**

```bash
# 服务器：~/.bashrc 追加
export all_proxy="socks5h://127.0.0.1:17890"
export ALL_PROXY="$all_proxy"
# 可同时保留 HTTP 兜底（给不支持 SOCKS 的工具）
export http_proxy="http://127.0.0.1:17897"
export https_proxy="$http_proxy"
export HTTP_PROXY="$http_proxy"
export HTTPS_PROXY="$http_proxy"
export no_proxy="127.0.0.1,localhost,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16"
export NO_PROXY="$no_proxy"
```

使之生效：

```bash
source ~/.bashrc
```

### 3.3 `~/.curlrc`（覆盖公司代理）

> 与上面二选一保持一致

**HTTP：**

```bash
cat > ~/.curlrc <<'EOF'
proxy = "http://127.0.0.1:17897"
noproxy = "127.0.0.1,localhost,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16"
EOF
```

**SOCKS：**

```bash
cat > ~/.curlrc <<'EOF'
proxy = "socks5h://127.0.0.1:17890"
noproxy = "127.0.0.1,localhost,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16"
EOF
```

### 3.4 验证（关键看连接目标）

```bash
# 期待看到：Trying 127.0.0.1:17897 或 :17890
curl -I -v https://www.google.com
```

如果仍出现 `Trying 10.22.96.29:8080`（公司代理），说明有别处继续注入：

* 搜索系统级注入点：

```bash
sudo grep -RniE '10\.22\.96\.29|proxy' \
  /etc/environment /etc/profile /etc/profile.d /etc/apt/apt.conf.d /etc/wgetrc 2>/dev/null
```

### 3.5 常用工具分别配置

**APT（仅支持 HTTP）**

```bash
sudo tee /etc/apt/apt.conf.d/99proxy >/dev/null <<'EOF'
Acquire::http::Proxy "http://127.0.0.1:17897/";
Acquire::https::Proxy "http://127.0.0.1:17897/";
EOF
```

**Git**

```bash
# 选 HTTP：
git config --global http.proxy  http://127.0.0.1:17897
git config --global https.proxy http://127.0.0.1:17897

# 或 SOCKS：
# git config --global http.proxy  socks5h://127.0.0.1:17890
# git config --global https.proxy socks5h://127.0.0.1:17890
```

**pip**

```bash
mkdir -p ~/.config/pip
tee ~/.config/pip/pip.conf >/dev/null <<'EOF'
[global]
proxy = http://127.0.0.1:17897
EOF
# 若 SOCKS：proxy = socks5h://127.0.0.1:17890
```

**conda**

```bash
conda config --set proxy_servers.http  http://127.0.0.1:17897
conda config --set proxy_servers.https http://127.0.0.1:17897
# 或：conda config --set proxy_servers.all_proxies socks5h://127.0.0.1:17890
```

**npm / yarn**

```bash
npm config set proxy http://127.0.0.1:17897
npm config set https-proxy http://127.0.0.1:17897
# SOCKS：npm config set proxy socks5h://127.0.0.1:17890
#        npm config set https-proxy socks5h://127.0.0.1:17890
```

**wget**

```bash
tee -a ~/.wgetrc >/dev/null <<'EOF'
use_proxy = on
http_proxy = http://127.0.0.1:17897
https_proxy = http://127.0.0.1:17897
EOF
```

**Docker（守护进程代理）**

```bash
sudo mkdir -p /etc/systemd/system/docker.service.d
sudo tee /etc/systemd/system/docker.service.d/http-proxy.conf >/dev/null <<'EOF'
[Service]
Environment="HTTP_PROXY=http://127.0.0.1:17897" "HTTPS_PROXY=http://127.0.0.1:17897" \
"NO_PROXY=127.0.0.1,localhost,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16"
EOF
sudo systemctl daemon-reload && sudo systemctl restart docker
```

> `sudo` 默认不继承 shell 变量，临时需 `sudo -E` 或按上面写入服务配置。
> 建议在 `sudo visudo` 添加：
> `Defaults env_keep += "http_proxy https_proxy HTTP_PROXY HTTPS_PROXY no_proxy NO_PROXY"`

---

## 4) 服务器浏览器走代理

**Firefox**
设置 → 常规 → 网络设置 → **手动代理**

* 选 HTTP：`127.0.0.1:17897`
* 或选 SOCKS v5：`127.0.0.1:17890` 并勾选“**Proxy DNS when using SOCKS**”
* 不代理：`127.0.0.1, localhost, 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16`

**Chrome/Chromium（命令行最干净）**

```bash
# HTTP
google-chrome --proxy-server="http://127.0.0.1:17897" \
              --proxy-bypass-list="127.0.0.1,localhost,10.0.0.0/8;172.16.0.0/12;192.168.0.0/16"

# SOCKS
# google-chrome --proxy-server="socks5://127.0.0.1:17890" \
#               --host-resolver-rules="MAP * ~NOTFOUND , EXCLUDE localhost"
```

**GNOME 系统代理（全局 GUI 应用复用）**

```bash
gsettings set org.gnome.system.proxy mode 'manual'
gsettings set org.gnome.system.proxy.http host '127.0.0.1'
gsettings set org.gnome.system.proxy.http port 17897
gsettings set org.gnome.system.proxy.https host '127.0.0.1'
gsettings set org.gnome.system.proxy.https port 17897
gsettings set org.gnome.system.proxy ignore-hosts \
"['127.0.0.1','localhost','10.0.0.0/8','172.16.0.0/12','192.168.0.0/16']"
```

---

## 5) 一键开/关脚本（服务器侧）

将下列内容保存为 `~/.proxyrc`，并在 `~/.bashrc` 末尾加入 `source ~/.proxyrc`：

```bash
proxy_on_http(){
  export http_proxy=http://127.0.0.1:17897
  export https_proxy=$http_proxy
  export HTTP_PROXY=$http_proxy HTTPS_PROXY=$http_proxy
  export no_proxy="127.0.0.1,localhost,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16"
  export NO_PROXY="$no_proxy"
  echo "[proxy] HTTP ON -> $http_proxy"
}
proxy_on_socks(){
  export all_proxy=socks5h://127.0.0.1:17890
  export ALL_PROXY=$all_proxy
  proxy_on_http
  echo "[proxy] SOCKS ON -> $all_proxy"
}
proxy_off(){
  unset http_proxy https_proxy ftp_proxy all_proxy HTTP_PROXY HTTPS_PROXY FTP_PROXY ALL_PROXY
  export NO_PROXY="127.0.0.1,localhost"
  echo "[proxy] OFF"
}
```

使用：

```bash
source ~/.bashrc
proxy_on_http      # 或 proxy_on_socks
proxy_off
```

---

## 6) 快速自检与排错

* **隧道是否仍在监听？**

  ```bash
  ss -tlnp | grep -E '17897|17890'
  pgrep -a ssh | grep 10.122.5.97
  ```

  无监听 → 重新在**本机**起 `ssh -fN -R ...`，或检查 `autossh` 服务状态。

* **curl 仍走公司代理？**
  `curl -I -v https://www.google.com`
  若显示 `Trying 10.22.96.29:8080`：

  1. 清空所有 `*_proxy` 变量；
  2. 用 `~/.curlrc` 覆盖；
  3. 搜索系统级注入（见 3.4 搜索命令）。

* **`HTTP/1.1 503 sddld / CONNECT failed`**
  说明请求被送到公司代理去了（非 127.0.0.1:17897/17890）。按上条处理。

* **`remote port forwarding failed`**
  远端端口占用/策略禁止。换端口（如 17898），或让管理员确认 `AllowTcpForwarding yes`。

* **DNS 泄露/站点仍不可达**
  优先用 **SOCKS5H**（`socks5h://`）+ 浏览器开启 *Proxy DNS*；Chrome 加
  `--host-resolver-rules="MAP * ~NOTFOUND , EXCLUDE localhost"`。

* **`ping` 不走代理**
  用 `curl`/`wget`/`git` 这类 HTTP(S) 工具测试，`ping` 走 ICMP 无代理意义。

---

## 7) 安全与建议

* 反向监听绑定在远端 `127.0.0.1`（回环），**不会外网暴露**；无需开启 Clash 的 “Allow LAN”。
* 若需要多台服务器复用本机代理，可为每台开一条 `autossh` 服务实例，监听不同端口。
* 生产脚本中避免硬编码密码，使用 SSH key。

---

### 迷你清单（你只需做的最少步骤）

1. **本机**起隧道（后台）：

```bash
ssh -fN -o ExitOnForwardFailure=yes \
    -o ServerAliveInterval=30 -o ServerAliveCountMax=3 \
    -R 127.0.0.1:17897:127.0.0.1:7897 \
    -R 127.0.0.1:17890:127.0.0.1:7890 \
    luolu@10.122.5.97
```

2. **服务器**验证：

```bash
ss -tlnp | grep -E '17897|17890'
curl -I --proxy http://127.0.0.1:17897 https://www.google.com
```

3. **PyCharm Host**：`HTTP 127.0.0.1:17897`（或 **SOCKS 127.0.0.1:17890**）。

4. **服务器命令行**：在 `~/.bashrc` 中加入（至少）：

```bash
export http_proxy="http://127.0.0.1:17897"
export https_proxy="$http_proxy"
export no_proxy="127.0.0.1,localhost,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16"
```

并写 `~/.curlrc`（覆盖公司代理）：

```bash
proxy = "http://127.0.0.1:17897"
noproxy = "127.0.0.1,localhost,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16"
```

5. **浏览器**：

* Firefox 手动代理；或
* Chrome 启动参数 `--proxy-server="http://127.0.0.1:17897"`

> 完成以上，你的 PyCharm Host、服务器命令行与浏览器就都会走你**本机 Clash**代理了。
